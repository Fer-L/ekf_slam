function [X, P, lm, H, R] = correction_step(X_pred, P_pred, sensor_data, N, lm, m)
addpath('tools');
%x_ = x_pred(1);
%y_ = x_pred(2);
%theta = x_pred(3);

Z = zeros(size(sensor_data, 2) * 2, 1);
Z_pred = zeros(size(sensor_data, 2) * 2, 1);
%len = size(x_pred, 1);
%expectedZ = zeros(mm*2, 1);
% H will be 2m x 2N+3
H = [];

%x_pred = zeros(3+2*N,1);
%R = diag([0.3, 3000]);

% Define the sensor noise covariance matrix Q (R)
% Q = diag([0.3, 4]);
%Q = diag([0.3, 3000]);

% for all observed features, do % linha 7
for i = 1:size(sensor_data, 2)
    %j = sensor_data(i).id
    lm_id = sensor_data(i).id;
    range = sensor_data(i).range;
    phi = sensor_data(i).bearing;

    % Add the landmark measurement to the Z vector
    %z = [range;
    %     phi];
    % 
    % if landmark s never seen before % linha 9 
    %if( isnan(MappedLandFeatures(i,2)))
    if(lm(lm_id)==false)
        %MappedLandFeatures(i,:) = [x_ + range * cos(phi + theta), y_ + range * sin(phi + theta)];
        X_pred(2 * lm_id + 2:2 * lm_id + 3) = [X_pred(1); X_pred(2)] + [range * cos(phi + X_pred(3)); range * sin(phi + X_pred(3))];
        %MappedLandFeatures(i,2) = 1;
		lm(lm_id) = true;
    end  
    Z(i*2-1:i*2) = [range; phi];

    delta = [X_pred(2 * lm_id + 2) - X_pred(1); X_pred(2 * lm_id + 3) - X_pred(2)];


    %delta = [MappedLandFeatures(i,1) - x_;
    %         MappedLandFeatures(i,2) - y_];

    q = delta' * delta;
    %sq = sqrt(q);

    Z_pred(i*2-1:i*2) = [sqrt(q); atan2(delta(2), delta(1)) - X_pred(3)];
    
    %z_hat = [sqrt(q);
    %         atan2(delta(2), delta(1)) - theta];

    Gxj = [eye(3), zeros(3, 2 * N - 3), zeros(3), zeros(3, 2 * N - 2 * N); zeros(3), zeros(3, 2 * N - 3), eye(3), zeros(3, 2 * N - 2 * N)];
	%Hi = zeros(3, size(X_pred, 1)); % talvez mudar aqui
    
	%Hi = zeros(2, len);
    %Hi(:, 1:3) = [-sq*delta' 0; delta(2) -delta(1) -q]/q;
    %Hi(:, 2*lm_id+2: 2*lm_id+3) = [sq*delta'; -delta(2) delta(1)]/q;
	% Augment H with the new Hi
	%H = [H;Hi];

    %h = zeros(2, N);
    h = 1/q * [-sqrt(q)*delta(1) -sqrt(q)*delta(2) 0 sqrt(q)*delta(1) sqrt(q)*delta(2) 0;
        delta(2) -delta(1) -q -delta(2) delta(1) 0] * Gxj;
    
    %h = X_pred(1) - X_pred()

    H = [H; h];
    %Hi(:, 2*lm_id+2: 2*lm_id+3) = [sq*delta'; -delta(2) delta(1)]/q;
	% Augment H with the new Hi
	%H = [H;Hi];

   % Gk = [eye(3) zeros(3,(2*j -2)) zeros(3,2) zeros(3,(2*N-2*j));
    %        zeros(2,3) zeros(2,(2*j -2)) eye(2) zeros(2,(2*N-2*j))];

    %low_H = [-sqrt(q)*delta(1) -sqrt(q)*delta(2) 0 sqrt(q)*delta(1) sqrt(q)*delta(2);
    %               delta(2) -delta(1) -q -delta(2) delta(1)];


    %H = ((1/q) * low_H) * Gk;
    R = eye(size(sensor_data, 2)) * 0.01;
    % Compute the Kalman gain \ linha 17
    K = P_pred * H' * inv(H * P_pred * H' + R);


    %x_pred += K * obs_diff;
    X_pred = X_pred + K * normalize_all_bearings(Z - Z_pred);
    X_pred(3) = normalize_angle(X_pred(3));
    P_pred = (eye(size(X_pred, 1)) - K * H) * P_pred;

    %K = p_pred * H' * inv(H * p_pred * H' + R);
    % A LINHA DEBAIXO
    %x_pred = x_pred + K * (z - z_hat); % linha 18 

    %x_local = x_local + K * (z - z_hat); % linha 18 

    %p_pred = (eye(2*N+3) - (K * H)) * p_pred;  
end
X = X_pred;
P = P_pred;
end
